<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>For Kelly</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
:root { --safe-pad: 14px; }

/* One screen, no scroll */
html, body {
height: 100%;
margin: 0;
overflow: hidden;
background: #fafafa;
color: #222;
font-family: -apple-system, BlinkMacSystemFont, sans-serif;
}

.wrap {
height: 100%;
display: flex;
align-items: center;
justify-content: center;
padding: var(--safe-pad);
box-sizing: border-box;
}

.card { width: min(720px, 100%); text-align: center; }

h1 {
font-weight: 500;
margin: 0 0 6px;
font-size: clamp(22px, 4.5vw, 30px);
}
.sub {
margin: 0 0 10px;
color: #666;
font-size: clamp(12px, 3.2vw, 14px);
}

img.hero {
width: min(52vw, 260px);
max-width: 260px;
min-width: 160px;
border-radius: 12px;
display: block;
margin: 10px auto 10px;
}

.question {
margin: 8px auto 8px;
font-size: clamp(14px, 3.9vw, 18px);
max-width: 42ch;
}

/* Stage for buttons - fixed height, stays inside screen */
.btn-stage {
position: relative;
width: min(520px, 100%);
height: 104px;
margin: 10px auto 0;
}

button {
border: 0;
padding: 12px 16px;
border-radius: 999px;
font-size: clamp(14px, 3.8vw, 16px);
cursor: pointer;
box-shadow: 0 6px 18px rgba(0,0,0,0.08);
user-select: none;
-webkit-tap-highlight-color: transparent;
touch-action: manipulation;
white-space: nowrap;
position: absolute;
z-index: 2;
}
button:active { transform: scale(0.98); }

/* YES slightly lower */
#yesBtn {
background: #111;
color: #fff;
left: 50%;
top: 62%;
transform: translate(-50%, -50%);
z-index: 3;
}

/* NO initially to the right of YES */
#noBtn {
background: #fff;
color: #111;
border: 1px solid #ddd;
left: 50%;
top: 62%;
transform: translate(-50%, -50%);
z-index: 4;
}

/* Initial dance: left-right wiggle around its initial spot */
@keyframes lrWiggle {
0% { transform: translate(-50%, -50%) translateX(-10px); }
50% { transform: translate(-50%, -50%) translateX(10px); }
100% { transform: translate(-50%, -50%) translateX(-10px); }
}
.wiggle { animation: lrWiggle 1s ease-in-out infinite; }

#reveal {
margin-top: 14px;
opacity: 0;
transform: translateY(6px);
transition: opacity 1.1s ease, transform 1.1s ease;
font-size: clamp(14px, 4vw, 18px);
}
#reveal.show { opacity: 1; transform: translateY(0); }

.footer {
margin-top: 12px;
color: #666;
font-size: clamp(12px, 3.2vw, 14px);
}

@media (max-height: 700px) {
img.hero { width: min(46vw, 230px); }
.btn-stage { height: 94px; }
}
@media (max-height: 620px) {
img.hero { width: min(42vw, 200px); margin: 8px auto; }
.btn-stage { height: 88px; }
.question { margin: 6px auto; }
}
</style>
</head>

<body>
<div class="wrap">
<div class="card">
<h1>For Dear Kelly</h1>
<p class="sub">February ¬∑ Tokyo</p>

<img class="hero" src="images/photo1.jpg" alt="Us" />

<div class="question">
Would you like to see the world with Han ?
</div>

<div class="btn-stage" id="stage">
<button id="yesBtn">Hell Yes ‚ù§Ô∏è</button>
<button id="noBtn" class="wiggle">Hell No üö´</button>
</div>

<div id="reveal">Can‚Äôt wait to see the world with youüåéüåçüåè</div>
<div class="footer">‚Äî Han</div>
</div>
</div>

<script>
const stage = document.getElementById("stage");
const yesBtn = document.getElementById("yesBtn");
const noBtn = document.getElementById("noBtn");
const reveal = document.getElementById("reveal");

// --- Helpers ---
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function rectRelativeToStage(el) {
const s = stage.getBoundingClientRect();
const r = el.getBoundingClientRect();
return {
left: r.left - s.left,
top: r.top - s.top,
width: r.width,
height: r.height
};
}

function overlap(a, b) {
return !(a.left + a.width <= b.left ||
b.left + b.width <= a.left ||
a.top + a.height <= b.top ||
b.top + b.height <= a.top);
}

// place a button by top-left px inside stage
function placeNo(leftPx, topPx) {
// switch NO to px positioning model (no -50% translate)
noBtn.style.transform = "translate(0,0)";
noBtn.style.animation = "none"; // stop wiggle once we start dodging

const s = stage.getBoundingClientRect();
const n = noBtn.getBoundingClientRect();

const minL = 2;
const maxL = s.width - n.width - 2;
const minT = 2;
const maxT = s.height - n.height - 2;

noBtn.style.left = clamp(leftPx, minL, maxL) + "px";
noBtn.style.top = clamp(topPx, minT, maxT) + "px";
}

// --- Initial layout: NO to the right of YES ---
// We set NO at a fixed offset to the right of YES, and ensure no overlap.
function setInitialNoPosition() {
const s = stage.getBoundingClientRect();

// Keep YES centered with translate; compute its center in stage coords
const y = rectRelativeToStage(yesBtn);
const n = rectRelativeToStage(noBtn);

// desired: to the right of YES with a gap
const gap = 14;
// Because YES uses translate(-50%,-50%), its "left/top" are not px-based yet.
// We'll temporarily compute a px placement for NO based on YES rect.
const desiredLeft = y.left + y.width + gap;
const desiredTop = y.top + (y.height - n.height) / 2;

// Convert NO to px-based placement but keep wiggle by adding class to stage later.
// We'll place it px-based then simulate wiggle by tiny periodic moves in JS.
// (CSS wiggle uses translate(-50%) which doesn't apply in px mode.)
noBtn.classList.remove("wiggle");
noBtn.style.position = "absolute";
noBtn.style.transition = "left 0.10s linear, top 0.10s linear";

placeNo(desiredLeft, desiredTop);

// Start a gentle left-right dance around its anchor using JS (1s cycle)
startDance();
anchor = getNoAnchor();
}

// --- Dance (Requirement #1) ---
let danceTimer = null;
let danceDir = 1;
let anchor = null;

function getNoAnchor() {
const n = rectRelativeToStage(noBtn);
return { left: n.left, top: n.top };
}

function startDance() {
stopDance();
danceTimer = setInterval(() => {
// small oscillation ¬±8px around anchor, only horizontally
if (!anchor) anchor = getNoAnchor();
danceDir *= -1;
const targetLeft = anchor.left + (danceDir * 8);
placeNo(targetLeft, anchor.top);
// ensure never overlaps YES
enforceNoOverlapNearAnchor();
}, 1000);
}

function stopDance() {
if (danceTimer) clearInterval(danceTimer);
danceTimer = null;
}

// --- Click dodge behavior (Requirement #2 + #3) ---
// On click: move a short distance from its INITIAL anchor, random direction,
// never too far, never outside stage, never overlapping YES.
const MAX_DODGE = 70; // "not going too far"
const MIN_DODGE = 22;

function enforceNoOverlapNearAnchor() {
// If overlap, shove NO further right (or left) within bounds, small steps
const y = rectRelativeToStage(yesBtn);
let n = rectRelativeToStage(noBtn);

if (!overlap(y, n)) return;

const s = stage.getBoundingClientRect();
const step = 10;

// try pushing right then left
for (let i = 0; i < 12; i++) {
placeNo(n.left + step, n.top);
n = rectRelativeToStage(noBtn);
if (!overlap(y, n)) return;
}
for (let i = 0; i < 24; i++) {
placeNo(n.left - step, n.top);
n = rectRelativeToStage(noBtn);
if (!overlap(y, n)) return;
}
}

function dodgeOnce() {
if (!anchor) anchor = getNoAnchor(); // anchor = initial-ish spot (right of YES)

stopDance(); // stop dancing after first click per your request

const y = rectRelativeToStage(yesBtn);
const n = rectRelativeToStage(noBtn);

// Try several random candidates around the anchor within a radius
const tries = 30;

for (let t = 0; t < tries; t++) {
const dx = (Math.random() < 0.5 ? -1 : 1) * (MIN_DODGE + Math.random() * (MAX_DODGE - MIN_DODGE));
const dy = (Math.random() < 0.5 ? -1 : 1) * (8 + Math.random() * 32); // modest vertical
const candidateLeft = anchor.left + dx;
const candidateTop = anchor.top + dy;

placeNo(candidateLeft, candidateTop);

const n2 = rectRelativeToStage(noBtn);

// must not overlap YES
if (!overlap(y, n2)) return;
}

// Fallback: if all candidates overlap, push away horizontally within bounds
enforceNoOverlapNearAnchor();
}

// YES click: hide buttons, reveal message
yesBtn.addEventListener("click", () => {
stopDance();
stage.style.display = "none";
setTimeout(() => reveal.classList.add("show"), 120);
});

// NO click: dodge near its initial spot
noBtn.addEventListener("click", (e) => {
e.preventDefault();
dodgeOnce();
});

// Optional: on touchstart, also dodge (makes it harder to tap)
noBtn.addEventListener("touchstart", () => {
dodgeOnce();
}, { passive: true });

// Keep layout sane on resize/orientation changes
window.addEventListener("resize", () => {
// Re-anchor and reposition NO to the right of YES, restart dance
anchor = null;
setTimeout(() => {
setInitialNoPosition();
}, 50);
});

// Kick off initial placement after first paint so sizes are correct
window.addEventListener("load", () => {
setInitialNoPosition();
});
</script>
</body>
</html>
